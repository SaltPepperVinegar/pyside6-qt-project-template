## üéØ Project Overview

This repository is a **PySide6 desktop application scaffold**, designed as a clean starting point for small to medium (and growing) Qt/Python applications.  
It provides a project layout and tooling so you can focus on business logic instead of wiring everything from scratch.

Key ideas:

- **Clear structure**: separation between `UI layouts (.ui) / generated code / business panels / widgets / services / core utilities`
- **Automatic UI code generation**: use `pyside6-uic` to convert `.ui` files into Python modules
- **Centralized logging**: consistent log directory and format
- **Single entry point & main window**: a `main()` function and a minimal `MainWindow`
- **Modern tooling**: `uv + black + ruff + mypy`

You can treat this repo as an ‚Äúempty shell‚Äù app with the architecture already in place, ready to be filled with your own features.

---

## üöÄ Getting Started

### 1. Install Python & create a virtual environment (using uv)

```bash
# Install a specific Python version
uv python install 3.12.0 --force

# Create a virtual environment
uv venv --python 3.12 .venv

# Activate the virtualenv (Windows PowerShell)
.\.venv\Scripts\activate

# Activate the virtualenv (Linux)
source .venv/bin/activate

# Install dependencies
uv pip install -r requirements.txt
```

### 2. Install / update dependencies

Whenever you add new dependencies:

```bash
# Install new dependency (example)
uv pip install some-package

# Sync to requirements.txt
uv pip freeze > requirements.txt
```

---

## ‚ñ∂Ô∏è Run the Application

From the project root (with the virtualenv activated):

```bash
python -m src.app.app
```

The entrypoint is `src/app/app.py`. The `main()` function will:

- initialize logging via `setup_logging()`
- create the `QApplication` instance
- create and show the `MainWindow`

---

## üõ†Ô∏è PyCharm File Watcher for Automatic UI Generation

You can configure a PyCharm File Watcher so that whenever you save a `.ui` file, `build_ui.py` is run automatically to regenerate the Python code.

### Setup steps

1. Open **Settings** ‚Üí **Tools** ‚Üí **File Watchers**
2. Click **+** (top right) ‚Üí choose **Custom**
3. Fill in:
   - **Name**: `Build UI`
   - **File type**: `QT UI Designer`
   - **Scope**: `Project Files`
   - **Program**: `$ProjectFileDir$\.venv\Scripts\python.exe`
   - **Arguments**: `$ProjectFileDir$/src/app/tools/build_ui.py`
   - **Working directory**: `$ProjectFileDir$`

After saving this configuration, every time you edit and save a `.ui` file, the corresponding module under `ui_generated` will be kept in sync.

---

## ‚úÖ Formatting & Static Analysis

The project is intended to work with the following tools (configured in `pyproject.toml`):

- **ruff**: linting + import sorting
- **black**: code formatting
- **mypy**: static type checking

### Suggested pre-commit workflow

Before committing, run:

```bash
black .
ruff check . --fix
mypy .
```

You can also wire these into your IDE or Git hooks (e.g. `pre-commit`) to automate checks.

---

## üß± Directory Structure & Recommended Usage

All core application code lives under `src/app`.  
Below is an overview of each directory/file, its **responsibility**, and **recommended usage**.

### Top level (project root)

- **`pyproject.toml`**  
  - Project metadata, dependencies, and script entrypoints.  
  - **Recommendation**: manage dependencies here; keep `requirements.txt` as a generated snapshot for deployment / simple environment recreation.

- **`requirements.txt`**  
  - Dependency snapshot generated by `uv pip freeze`.  
  - **Recommendation**: update this whenever dependencies change to keep team / CI environments consistent.

- **`README.md`** (this file)  
  - Documents the purpose, structure, and usage of the project.

---

### `src/app`: application root

- **`app.py`**  
  - Application entrypoint containing the `main()` function.  
  - **Recommendation**: keep this file focused on high-level wiring only (create `QApplication`, initialize logging, show main window), and avoid putting business logic here.

- **`main_window.py`**  
  - Minimal example of a `QMainWindow` (menu + status bar + central label).  
  - **Recommended usage**:
    - Over time, evolve this into the central place that loads generated UI classes and composes your business panels.
    - Keep only ‚Äúshell-level‚Äù responsibilities here: menu bar, toolbars, main layout, global shortcuts, etc.

- **`__init__.py`**  
  - Marks `app` as a Python package; typically empty of business logic.

---

### `src/app/core`: core infrastructure

- **`core/logging.py`**  
  - Provides `setup_logging(app_name: str = "my_pyside_app")` to initialize application-wide logging:
    - Log directory: `~/.{app_name}/logs/app.log`
    - Writes to both console and rotating log file (`RotatingFileHandler`).  
  - **Recommended usage**:
    - Call `setup_logging()` at the very beginning of `app.py`.
    - In your code, always use `logging.getLogger(__name__)` instead of creating custom loggers manually.

> You can extend `core` with other cross-cutting concerns such as configuration loading, i18n, global error handling / reporting, theme management, etc.

---

### `src/app/ui`: raw Qt Designer layouts (.ui files)

Example structure:

- **`ui/main_window.ui`**: main window layout
- **`ui/panels/*.ui`**: layouts for larger business panels (e.g. `project_panel.ui`)
- **`ui/widgets/*.ui`**: layouts for reusable composite widgets (e.g. `project_widget.ui`)

**Recommended usage:**

- All layouts created with Qt Designer should live under `ui`, organized by purpose:
  - `ui/main_window.ui`: overall application frame
  - `ui/panels/`: large areas like side panels, workspaces, etc.
  - `ui/widgets/`: reusable smaller components, e.g. file pickers, property editors, etc.
- Do **not** hand-edit or store `.ui` files inside `ui_generated` ‚Äî that directory is for generated code only.

---

### `src/app/ui_generated`: generated UI code (do not edit)

Python modules generated from `.ui` files via `pyside6-uic`, for example:

- `ui_generated/main_window_ui.py`
- `ui_generated/panels/project_panel_ui.py`
- `ui_generated/widgets/project_widget_ui.py`

**Recommended usage:**

- Treat this as a **read-only directory**. If you need changes, modify the corresponding `.ui` file under `ui` and regenerate.
- Your business-layer classes in `panels` / `widgets` should **inherit from** these generated classes instead of modifying them directly.

Example pattern (not included in this repo, just a suggested approach):

```python
# src/app/panels/project_panel.py
from PySide6.QtWidgets import QWidget
from src.app.ui_generated.panels.project_panel_ui import Ui_ProjectPanel

class ProjectPanel(QWidget, Ui_ProjectPanel):
    def __init__(self, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        self.setupUi(self)
        # Connect signals and implement business logic here
```

---

### `src/app/panels`: feature panels / pages

- Contains ‚Äúlarger‚Äù chunks of UI with full features, usually:
  - inheriting from a class in `ui_generated.panels.*`, or
  - building the layout manually while still acting as a logical ‚Äúpage‚Äù or ‚Äúpanel‚Äù.

**Recommended usage:**

- Split files by feature domain, for example:
  - `project_panel.py`: project management UI logic
  - `settings_panel.py`: settings/preferences page
- Avoid direct network/file access here; instead, delegate to `services` for better separation of concerns.

---

### `src/app/widgets`: reusable widgets

- Houses reusable custom widgets that may appear in multiple panels, such as:
  - project list widgets
  - status indicators
  - custom input widgets, etc.

**Recommended usage:**

- When a certain UI fragment appears in multiple places, extract it into a widget under `widgets`.  
- As with panels, you can inherit from generated classes under `ui_generated.widgets.*`.

---

### `src/app/services`: business services / data layer

- Encapsulates **non-UI business logic**, such as:
  - HTTP/API calls
  - local configuration or file I/O
  - data models and validation (possibly using `pydantic`)

**Recommended usage:**

- `panels` and `widgets` call into `services` to fetch or mutate data; they should not directly talk to external systems whenever possible.
- You can organize services by domain, e.g. `project_service.py`, `settings_service.py`, `auth_service.py`, etc.

---

### `src/app/resources`: static assets

- Place icons, images, stylesheets (`.qss`), translation files, etc. here.  
- You can further split it into `icons/`, `images/`, `styles/`, `translations/`, and so on.

**Recommended usage:**

- Consider using Qt‚Äôs resource system (`.qrc`) or maintain a simple path helper to keep resource paths consistent.
- For larger projects, a small `resource_manager.py` can help centralize asset loading.

---

### `src/app/tools`: development utilities

- **`tools/build_ui.py`**  
  - Scans `src/app/ui` for `.ui` files and runs `pyside6-uic` to generate Python modules in `src/app/ui_generated`.
  - Example mapping:
    - `ui/panels/project_panel.ui` ‚Üí `ui_generated/panels/project_panel_ui.py`

**Recommended usage:**

- Run manually during development:

  ```bash
  # From project root
  python src/app/tools/build_ui.py
  ```

- Or configure your IDE to trigger it automatically (see PyCharm File Watcher below).

---


## üß≠ How to Build on This Template

1. **Design your screens first**  
   - Use Qt Designer to build the main window and core panels under `ui/`.
   - Run `build_ui.py` to generate `ui_generated` modules.

2. **Implement UI logic in `panels` / `widgets`**  
   - For each `.ui` layout, create a corresponding Python class that inherits from the generated `Ui_*` class.
   - Call `setupUi(self)` in `__init__` and connect signals/slots there.

3. **Centralize business logic in `services`**  
   - Extract networking, file I/O, configuration, etc. out of the UI layer and into dedicated services.

4. **Keep infrastructure in `core`**  
   - Logging, configuration, error handling, theming, etc. all belong in `core`, not in individual panels.

5. **Maintain structural consistency**  
   - When adding new features, decide upfront whether something is a panel, widget, service, or core utility, instead of putting everything into `main_window.py` or a single ‚Äúgod file‚Äù.

This way, you get a clean, extensible PySide6 foundation that can grow with your application.  
If you have specific business scenarios in mind, we can further refine naming conventions and directory splits to match your domain.
